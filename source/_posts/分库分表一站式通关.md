---
categories: 整理输出
tags:
  - 分库分表
sticky: ''
description: ''
permalink: ''
title: 分库分表一站式通关
date: '2025-09-14 17:39:00'
cover: 'https://prod-files-secure.s3.us-west-2.amazonaws.com/143cad91-961b-48b0-82dc-78fbb6eb5abe/7ed43b9e-92ec-4652-bf8e-e5b44810d8c9/wallhaven-e8oqdw.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB4667HKUNUME%2F20250918%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250918T060040Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjED4aCXVzLXdlc3QtMiJHMEUCIQCbu3VtJJM6nqTK8xUSnz0N8LMAFYY3oXOHn2BNElIg%2FwIgNbiFuQ1z4%2FGMeSeA9WLGEASMA8hCMXPTSoWl%2F%2FXijQ0qiAQIt%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAAGgw2Mzc0MjMxODM4MDUiDLVXt9uSM5Uon2ZlrCrcAyp16EMvOc9D6zQhIM%2Fot4YTDk2MLxhGqUqb5BXnpxno3xAp5RbUaLMN4MyQDC9DxNKyFu4MjGAks0BWwa68uC%2B2IrLGVSHcEKkq9lbL%2FnKoXCKHTdEco99k1NgKE2hXGuTdRfmgC1OUowX1Irrym6%2BLi4nkFu%2FQSPLtcu4vpeM17%2BGEDGOPg%2FYoGff4v2oaCpsABEecoxr%2B%2FIqy91%2FfKT0YSMZG7De6USg%2B3dkiJePfVf9XRSVtdIWls0ueLxkGU3Ud%2FS7rKbS7Fiv6YrfYmLskAhM8PpkcKUE5kQiMXvBwjavli8YQefz1Zg2JwF1Olx2LLlkXSaEcCicEdqHzm8x42AG98OuwYi3xLp9d%2Fh01y4kg6dnO4jK0aSOzE5yn4ANMF8aF5XjlighaEYn3B4lYG%2B%2FhK0dGj8CFi%2B1jdT6evvHcKReBX9M8EUBR5xYTb9nUzwBnT0%2B9JS8u1d6SaIjncQesLEPFbdOnklvKVifHRc5ra7YOOSTl6qXQ3rWrCdsU2hGBje4CceAFESU0RYcTxnhiVP3%2F8SOVUAtb%2F3RL7HOVR3jUOvndgvaw2scj4ucJwGEOtUMFcUdCQMr%2BhuhplGqEFbyXZBVaQZXXre5GZ6%2Bo4q7l08RFNi%2FUMLe2rsYGOqUBTfAMQV1mtCYB6bG%2F5x3HBdcr2d5i2E1jxT30eIwg%2FHsimMUf7%2F9hUhGDemuOnQgEgPHmD3oWj5L%2Fzqkd8KkdqAz1KHMd55AXXY3nWddeJb9iSp7WqNyOIOdWQoOt4ccvm2n4tFBDesTBkHsjaxCzoEQb%2BrFxb0loNSxcNR4nq%2BvF%2FuTQAWMnPJsEz%2BpNTLXLvFBuA8pRbKL3EAdl0f4qGDtwAvD9&X-Amz-Signature=609331b400d867009380044084a7c27c6c4d3511ed9f9846801103e5af51f5ef&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject'
updated: '2025-09-16 14:02:00'
index_img: /images/a81f4f13f0e342b1872c04a3976cfa12.jpg
banner_img: /images/a81f4f13f0e342b1872c04a3976cfa12.jpg
---
> 对于提前知道数据量大的项目，直接分8个或者16个库

美团用的是取模分


在进行分库分表之后，禁止没有使用**主键**的查询语句


# 基本概念


只分表：单表数据量大，读写出现瓶颈，这个表还能支撑未来几年的增长。


只分库：整个数据库出现性能瓶颈，例如数据库连接被打满了，或者并发量太大了，需要把库拆开


分库分表：单表数据量大，所在库也出现性能瓶颈，就要既分库又分表。


垂直拆分：把字段拆开到另一个表


水平拆分：把记录分开


# 分库分表的场景


一般情况下，单表数据量达到千万级别，就可以考虑分库分表了。


具体是否分库分表还需要看具体的业务场景，例如流水表，记录表数据量非常容易到达千万级、亿万级，需要在设计数据库表的阶段就进行分表，还有一些表虽然数据量只有几百万，但字段非常多，而且有很多text、blog格式的字段，查询性能也会很慢，可以考虑分库分表。


# 分库分表具体步骤


原则：


1 能不分就分表，优先进行**数据库调优**


**2.分片数量尽量少。**


分片尽量均匀分布在多个 DataHost 上，因为一个查询 SQL 跨分片越多，则总体性能越差，虽然要好于所有数据在一个分片的结果，只在必要的时候进行扩容，增加分片数量。


**3.不要一个事务里跨越多个分片查询**


尽量不要在一个事务中的 SQL 跨越多个分片，分布式事务一直是个不好处理的问题


## 拆分

- 业务拆分
    - 混合业务拆分
    - 具体业务拆分
        - 电商网站：一个典型的混合业务，包含用户信息、订单信息、商品信息等。可以将用户信息、订单信息和商品信息分别拆分到不同的库或表中，以减少数据冗余并提高访问效率。
        - 社交媒体平台：包含用户信息、好友关系、动态信息等。可以将用户信息和好友关系分离存储，以便更好地支持好友关系的查询和更新。
- 冷热分离

# 主键设计（路由规则）


使用带有业务属性作为自增id，可以不依赖于第三方id生成器


id可以使用雪花，或者就是自增id


[路由规则](https://fangkuaipai.notion.site/link-80fe6d2683314170aefd027030d27fc8)


**4.7 分布式id生成器**


在分库分表的情况下，数据库的自增主键已经无法使用。所以要使用一个分布式的id生成器。分布式事务id生成器要满足以下条件：唯一、趋势递增(减少落库时的索引开销)、高性能、高可用。


目前主流的分布式id生成方案都有第三方组件依赖，如：

- 基于zk
- 基于mysql
- 基于缓存

twitter的snowflake算法是一个完全去中心化的分布式id算法，但是限制workid最多能有1024，也就是说，应用规模不能超过1024。虽然可以进行细微的调整，但是总是有数量的限制。


另外，美团之前在github开源了一个leaf组件，是用于生成分布式id的，感兴趣的读者可以研究一下。


这里提出一种支持动态扩容的去中心化分布式id生成方案，此方案的优势，除了保证唯一、趋势递增，没有第三方依赖，支持存储的动态扩容之外，还具有以下优势：

- 支持按照时间范围查询，或者 时间范围+ip查询，可以直接走主键索引；
- 每秒的最大序列id就是某个ip的qps等

```plain text
12位日期+10位IP+6位序列ID+4位数据库扩展位
```


其中：


**12位日期：**格式为yyMMddHHmmss，意味着本方案的id生成策略可以使用到2099年，把时间部分前置，从而保证趋势递增。


**10位ip：**利用ip to decimal算法将12位的ip转为10进制数字。通过ip地址，来保证全局唯一。如果ip地址被回收重复利用了，也不用担心id的唯一性，因为日期部分还在变化。


**6位序列id：**意味着每秒最多支持生成100百万个id(0~999999)。不足6位前置补0，如000123。


**4位数据库扩展位：**为了实现不迁移数据的情况下，实现动态扩容，其中2位表示DB，2位表示TB，最多可扩容到10000张表。假设每张表存储1000万数据，则总共可以支持存储1000亿条数据。


关于数据库扩展位实现动态扩容图解：


![images689b591a3f2cd0bac26dd774d2a29472.webp](/images/e10088dc5edc4a31c814808b36f5bc92.webp)


**首先明确一点，路由策略始终根据数据库最后四位，确定某一条记录要到哪个分库的哪个分表中。例如xxxx0001，意味着这条记录肯定是在00分库的01分表上。**


接着，就要在id的生成策略上做文章。


假设初始状态为两个分库db_00,db_01，每个分库里面有10张分表，tb_00tb_09。此时，业务要保证生成id的时候，始终保证db的两位在0001之间，tb的两位始终在00~09之间。路由策略根据这些id，可以找到正确的分库分表。


现在需要扩容到10个分库，每个分表10个分表。那么DBA首先将新增的分库：db_02db_09创建好，每个分库里面再创建10个分表：tb_01tb_09。业务同学在此基础上，将id生成策略改成：db的两位在00~09之间，tb的两位规则维持不变(只是分库数变了，每个分库的分表数没变)。而由于路由从策略是根据最后四位确定到哪个分库，哪个分表，当这些新的分库分表扩展位id出现时，自然可以插入到新的分库分表中。也就实现了动态扩容，而无需迁移数据。


当然，新的分库分表中，一开始数据是没有数据的，所以数据是不均匀的，可以调整id扩展位中db和tb生成某个值的概率，使得落到新的分库分表中的概率相对大一点点(不宜太大)，等到数据均匀后，再重新调整成完全随机。


此方案的核心思想是，预分配未来的可能使用到的最大资源数量。通常，100个分库，每个分库100张分表，能满足绝大部分应用的数据存储。如果100个分库都在不同的mysql实例上，假设每个mysql实例都是4T的磁盘，那么可以存储400T的数据，基本上可以满足绝大部分业务的需求。


当然，这个方案不完美。如果超过这个值，这种方案可能就不可行了。然而，通常一个技术方案，可以保证在510年之间不需要在架构上做变动，应该就算的上一个好方案了。如果你追求的是完美的方案，可能类似于TIDB这种可以实现自动扩容的数据库产品更适合，不过目前来说，TIDB等类似产品还是无法取代传统的关系型数据库的。说不定等到510年后，这些产品更成熟了，你再迁移过去也不迟。


# 海量数据存储


## 分区


表分区是一种数据存储方案，可以解决单表数据较多的问题。

> 底层就是一张表的数据被拆到了多个表文件存储了；从逻辑看，他们对外是一张表。

所以想要提高磁盘IO，就得把这个放在多个磁盘中


分区策略：

- Hash
    - 进行hash运算
- Range
    - 分配几个区间，数值在这个区间的就存，0-10,11-20，大于20 等
- List
    - 提前定好每个key可以放置的区间，不匹配的不能放进去
- Key

分区的问题：尾部热点问题，因为可能大量的数据都是查询后面的数据


整体的QPS没有降下来，所以该分表的时候还是得分表


## 分表


垂直分表：字段分离（一些不常用的在另外一个表）


# sharding-jdbc使用相关


分片算法：

1. 精确分片算法： = 和in
2. 范围分片算法：between
3. 复合分片算法：多个字段的值
4. Hint分片算法：强制路由，

广播表：每个库中都一样，只要修改一个，别的也会进行同步（例如**字典表**）


绑定表：主表和子表，防止笛卡尔积（需要保证两个的分片策略相同）


通常在我们的业务中都会使用 `t_order` 和 `t_order_item` 等表进行多表联合查询，但由于分库分表以后这些表被拆分成N多个子表。如果不配置绑定表关系，会出现笛卡尔积关联查询，将产生如下四条`SQL`。


```plain text
SELECT * FROM t_order_0 o JOIN t_order_item_0 i ON o.order_id=i.order_id
SELECT * FROM t_order_0 o JOIN t_order_item_1 i ON o.order_id=i.order_id
SELECT * FROM t_order_1 o JOIN t_order_item_0 i ON o.order_id=i.order_id
SELECT * FROM t_order_1 o JOIN t_order_item_1 i ON o.order_id=i.order_id
```


![images5c59b68dd8a91f20f8b2b065f45bf4d1.png](/images/cff57164b3ce92134fa929ac23c8bd9d.png)


而配置绑定表关系后再进行关联查询时，只要对应表分片规则一致产生的数据就会落到同一个库中，那么只需 `t_order_0`和 `t_order_item_0` 表关联即可。


```plain text
SELECT * FROM t_order_0 o JOIN t_order_item_0 i ON o.order_id=i.order_id
SELECT * FROM t_order_1 o JOIN t_order_item_1 i ON o.order_id=i.order_id
```


![images592b93f7c42ba06e785aaaece51c4be0.png](/images/5d0a5b17bfe438af149895e9f14c3550.png)


分片策略：是分片算法+分片键


跨数据源的复杂查询


---


海量数据高并发的 OLTP 场景


由于关系型数据库大多采用 B+ 树类型的索引，在数据量超过阈值的情况下，索引深度的增加也将使得磁盘访问的 IO 次数增加，进而导致查询性能的下降。通过 ShardingSphere 数据分片，按照某个业务维度，将存放在单一数据库中的数据分散地存放至多个数据库或表中，可以达到提升性能的效果。通过使用 ShardingSphere-JDBC 接入端，可以满足高并发的 OLTP 场景下的性能要求。


海量数据实时分析 OLAP 场景


在传统的数据库架构中，如果用户想要进行数据分析，需要先使用 ETL 工具，将数据同步至数据平台中，然后再进行数据分析，使用 ETL 工具会导致数据分析的实效性大打折扣。ShardingSphere-Proxy 提供静态入口以及异构语言的支持，独立于应用程序部署，适用于实时分析的 OLAP 场景。


---


# 数据扩容中的解决方案


## 停机方案


## 停写方案


只接收读请求（需要进行拦截）

> 技术实现上比较难

## 日志方案


在写的同时把新增，修改，删除的记录写到日志中。


然后切换的同时把新的数据也导进去。


# 实际场景中的使用


直接分2048个表，主键后面使用用户 id，用 id 对2048进行取模即可


然后这都是分表，如果数据库连接多了，直接迁移数据即可，成2倍的增加


对业务进行改造，比如黑名单功能，A 拉黑 B


改造成 A 拉黑 B，B 被 A拉黑，两条记录


# 分库分表常见问题参考答案（收录25年至今的牛客面经）


分库分表的常用中间件有哪些？

> mycat sharding-jdbc

有哪些问题中间件无法提供帮助、只能改写业务代码的场景？

> 跨分片的复杂查询

分库分表的实现场景和方式有哪些？

> 

分表之后，要查询两个表的数据要怎么查？

> 全局查询法，把每个表中的前xx条取出来，然后进行分页Sharding-Jdbc分页修正 就是上面的方案  
> 缺点：深分页就不行了不允许跳页，只能顺序往下查二次查询法
>
> [https://www.notion.so/link-mysql-4bbe37e2f4bc44a1b86bd64de88c42e7](https://www.notion.so/link-mysql-4bbe37e2f4bc44a1b86bd64de88c42e7)
>
>

分库分表的优缺点是什么？

> 优点：提升性能，增强存储能力
>
> 缺点：复杂查询不能，分布式事物
>
>

为什么做了分库分表后分页比较困难了？

> 数据不在一个表中，而且顺序不一样

如果10亿数据要分表，要怎么分？业务怎么切？

> 分库+分表

分库分表怎么保证数据一致性？

> 本身保证，xa 或者base

选的什么分片键？什么分片算法？

> 用用户id mod切分

分库分表后的分布式ID怎么做？

> 给我雪花

（2025年目前为止的牛客面经关于分库分表的问题收集）


总结：


分布式事务一致性问题


跨节点关联查询JOIN问题（解决方案：1.全局表 2.冗余字段 3.建立1：1的ER实体关系分片）


非分片键的查询问题（1.创建映射表 2. 前缀分片法 3.使用ES搜索引擎（最后才说要抬高立意）


全局分布式ID问题（1.UUID2.雪花算法3.mysql/Redis4.美团Leaf（1.Leaf-segment 2.Leaf-snowflake）


跨库跨节点分页查询问题（不会）


参考面试回答：（吟唱）


**面试官：分库分表后、如何解决跨节点JOIN查询问题**


`&lt;参考回答：&gt;`


分库分表后、跨节点 JOIN 查询会带来性能问题。 为了解决这个问题主要有以下几种方案：

1. 全局表： 如果是一些数据量小、变动不频繁的基础数据（比如权限表、配置表、商品分类表）可以将它们复制到每个数据库节点。 这样查询时可以直接在本地 JOIN、避免跨库。 但需要保证全局表的数据同步。
2. 冗余字段： 如果经常需要 JOIN 某些字段、可以将这些字段冗余存储到需要查询的表中。 比如在订单表中冗余存储用户的姓名和地址。 这样查询订单信息时、就不用 JOIN 用户表了。 但需要保证冗余字段的数据一致性。
3. ER 分片： 如果表之间存在很强的关联关系、比如订单表和订单详情表、可以按照相同的规则进行分片、保证它们在同一个数据库节点上。 这样就可以避免跨库 JOIN。

（ER: 例如将订单表 和订单详情表按照 订单ID进行分片）


使用一致性哈希算法、将 订单ID映射到不同的数据库节点上。


关键： 保证具有相同 订单ID 的订单表记录和订单详情表记录、始终被分配到同一个数据库节点上。)


**面试官：非分片键的字段如何查询问题**


`&lt;参考回答：&gt;`


问题背景：我们选择分片键的时候都是选用查询场景最多的字段来做分片键、但是可能需要查询非分片键下的所有所有数据。例如电商用(订单ID) 做分片但是我们可能会查询订单类型、这些数据可能被分到了不同的库、我们需要聚合所有库的查询、然后返回给前端。导致效率低下


回答参考方案：


**1.关系映射表：映射关系表就是存储待查询字段和分片键映射关系的一张表、当要使用非分片键查询的时候、先到映射关系表中查询字段所对应的所有分片键、再根据分片键查询所有信息。**


（例如创建一个额外的映射表Map、包含 订单ID 和 订单类型 的对应关系。当插入新订单时、同时更新这个映射表。查询时先查映射表获取所有的 订单ID、再根据 订单ID列表查询分片表。总结一下就是用映射去查询我们就可以得到了 缺点是要维护新的Map 适用于对实时性要求不高的情况）


**2. 前缀分片法：利用（订单ID）的某些特征来决定数据存储在哪个分片上，并将这个嵌入到主键中。 这样既可以通过主键进行分片、又可以通过UID进行分片。**


（例如在生成 订单时，嵌入 用户ID 的某些特征 例如 用户ID的最后一位。然后使用包含这个 订单ID进行分片。这样既可以通过 订单分片，也可以通过 用户ID的特征进行路由。优点不需要额外的存储空间 缺点是可能会产生如果 用户ID分布不均匀、可能会导致数据倾斜）


**3.ES: 将所有订单数据同步到ES中、利用 ES 的全文检索和聚合分析能力、进行多条件查询**

