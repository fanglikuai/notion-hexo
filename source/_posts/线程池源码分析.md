---
categories: 源码阅读
tags:
  - juc
sticky: ''
description: ''
permalink: ''
title: 线程池源码分析
date: '2025-09-14 17:39:00'
cover: 'https://prod-files-secure.s3.us-west-2.amazonaws.com/143cad91-961b-48b0-82dc-78fbb6eb5abe/c483963b-eee5-43c8-af71-1f377fe9d74f/wallhaven-x6v3yl.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB466W3FCQKAN%2F20250916%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250916T170043Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEBgaCXVzLXdlc3QtMiJHMEUCICP7RqtV7qj957v0qZ0GxreuEP06NLJoKHjFbh3q39NKAiEAlRnTJoVUM%2BNUzZ5XdEfQ3ozLeZYceoLBAVBPtOgJCDsqiAQIkf%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAAGgw2Mzc0MjMxODM4MDUiDF9bPm63QkTpKoQWJSrcA1n3UoyC2UMGdK6ABFqieVolAWHNDWsqDMEGns8%2FKdzmms1b9JkjAWbP2G1emPg8MoSUuV7K1e0qYTTObvoB8YOb3WvQ5W89FjUZJU%2FD3hJ0meondfOiQT4wuIKohDZsU8JO2BRaiK7HK48pG8%2FSSCF%2F7aHaWVWJS07YPfiRdru4Q1jUakMXv6bcg9W6KO7Bpc953V8EikBvcdDh4mJ%2FO8PVYKO1p%2FnJhIvh7r8LWsDMlSlCT4XyEg9DJeD6C5OncoMkXe8SVj97ZTRQjc5VEar4E1A1VTncjRCK6m12VF0YlmuQUiDRc0YOoqp2IrzAijGJdVchic4ppCQcHIXpXS%2FaxxxC7YF2cuJFinkekUyaNQbVXRw2J%2Fs4sAV9P5kuhHykLxeY%2F9GsxXPB3Cdoc%2BszK4uQr8UKjItZ2%2FtgaYD1%2B0O8A%2FeCKovL2lUCkZLI40wcGeSe%2Bgv84pgh%2F8MlXYF9%2BGeE3sMUDb81Usuc3Q3AGkeBOoyC2TCD0VHqA7QAUPVbEYZ8CdqpCqjfhL0%2BkawFB%2BIKyWmJ0j5xat41hUbaw4cY94VaAFdTFd9LopQLRFKw%2BCMOwZ%2FRx3hlyh9PiH28JyXlYB6POrc3WJ%2BstFH%2BpcE6c5ivGZVPBCmmMPmYpsYGOqUBliJ7CMAwCSLaKilqp248mWIfPAXBj9pISkYlphCrWuoUJKsEg01WM9ef9QPDuOWt5Mmaz63WLAVBJyupcK8CiW97Zs9lvJ4wI1O2BF%2BxfELlaYPoC6wGGSBzbQSVGmuG6aWPR2yTP2cq2P0SD%2FawiAewyCdmnXPpIEbXBLL7cnOsqczcONrQCXwLG2XGsFnnd7oAI06tL5yXZxbDLffmIDoY5%2FdT&X-Amz-Signature=6cb4341e1219314ac6834f2ea69902e77f1d972156010bb705cc2167b0159ae1&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject'
updated: '2025-09-16 14:07:00'
index_img: /images/adb24a854bcf5498818e19d9afe76934.jpg
banner_img: /images/adb24a854bcf5498818e19d9afe76934.jpg
---

线程池优点：

1. 提高性能
2. 资源管理
3. 控制并发度
4. 提高响应速度
5. 简化编程

# 线程池核心组件

1. 线程池管理器（ThreadPoolExecutor）
2. 工作线程
3. 任务队列
4. 拒绝策略

# 类的结构


核心接口


![imagesd1bf1c87a32958f75e85ab46fad7b224.png](/images/83bf8a7309935c1ec889bf7848cb773b.png)


Executor如下，就一个方法


![images133dcc081cc1064650ef17f4935ebb04.png](/images/f395337498e20184c71a1c407242c1e7.png)


ExecutorService 定义了一些线程池的常用操作


![images1dc222f142cfdac2861c70c0af7e2665.png](/images/b28ce6dcd95f1d4d744b322da60a1cc8.png)


AbstractExecutorService：实现了一些方法


**ThreadPoolExecutor**：核心类


ScheduledThreadPoolExecutor：延迟执行等


# 字段解析


```java
// 二合一，线程池状态和线程数量
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));

// 值是29，表示线程池最大线程数量占用的二进制位；左移29位可获得线程池状态
private static final int COUNT_BITS = Integer.SIZE - 3;

// 用于获取线程池的容量？
private static final int COUNT_MASK = (1 << COUNT_BITS) - 1;

// runState is stored in the high-order bits —— 都表示线程池的状态
private static final int RUNNING    = -1 << COUNT_BITS;
private static final int SHUTDOWN   =  0 << COUNT_BITS;
private static final int STOP       =  1 << COUNT_BITS;
private static final int TIDYING    =  2 << COUNT_BITS;
private static final int TERMINATED =  3 << COUNT_BITS;
```


```java
/**
 * 队列
 */
private final BlockingQueue<Runnable> workQueue;

/**
 * 线程池相关操作锁，全局锁，重要操作需要上锁，比如：添加工作线程、关闭线程池等
 */
private final ReentrantLock mainLock = new ReentrantLock();

/**
 * 存放所有的工作线程
 */
private final HashSet<Worker> workers = new HashSet<>();

/**
 * 锁的条件变量，线程值终止时会用到
 * Wait condition to support awaitTermination.
 */
private final Condition termination = mainLock.newCondition();

/**
 * 核心线程是否也根据存活时间来决定消亡
 * If false (default), core threads stay alive even when idle.
 * If true, core threads use keepAliveTime to time out waiting for work.
 */
private volatile boolean allowCoreThreadTimeOut;

/**
 * The default rejected execution handler. 默认就是丢弃 抛异常
 */
private static final RejectedExecutionHandler defaultHandler = new AbortPolicy();
```


## 任务执行


![images9d351ecc0e59a5595e8042241594c0da.png](/images/25389afa59df657ce6ac2471b3a3509e.png)

- 添加工作线程子流程（?）
- 如果任务添加到队列成功，但是线程池状态变成非RUNNING状态，就需要从队列中移除任务，如果移除成功则执行拒绝策略逻辑，如果移除失败再看线程池是否还有线程，有的话就由这些工作线程去队列获取任务并执行，没有工作线程的话那就添加一个工作线程去阻塞队列拿任务执行。

### 提交流程


![imagesc22014600e40d8fc8085d66b1d49c7aa.png](/images/3e215bb557ea281e3727429c845cb303.png)


```java
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    /*
     * Proceed in 3 steps:
     *
     * 1. If fewer than corePoolSize threads are running, try to
     * start a new thread with the given command as its first
     * task. The call to addWorker atomically checks runState and
     * workerCount, and so prevents false alarms that would add
     * threads when it shouldn't, by returning false.
     *
     * 2. If a task can be successfully queued, then we still need
     * to double-check whether we should have added a thread
     * (because existing ones died since last checking) or that
     * the pool shut down since entry into this method. So we
     * recheck state and if necessary roll back the enqueuing if
     * stopped, or start a new thread if there are none.
     *
     * 3. If we cannot queue task, then we try to add a new
     * thread. If it fails, we know we are shut down or saturated
     * and so reject the task.
     */
    int c = ctl.get(); // 线程池的核心线程不够，创建核心线程
    if (workerCountOf(c) < corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    // 两种情况，1.线程池的线程大于等于核心线程数了，
    // 添加核心线程失败，判断是不是running状态
    if (isRunning(c) && workQueue.offer(command)) {
        int recheck = ctl.get();
        // 不是运行状态并且任务移除成功了，就拒绝
        if (!isRunning(recheck) && remove(command))
            reject(command);
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    // 队列也满了，增加非核心线程
    else if (!addWorker(command, false))
        reject(command);
}
```


### 添加工作线程


```java
/**
 * task: 可以为 null
 * core: 是否是核心线程
 *       实际上就是判断当前线程数要 < corePoolSize 才能添加线程
 */
private boolean addWorker(Runnable firstTask, boolean core) {
    retry:
    for (int c = ctl.get(); ; ) {
        // Check if queue empty only if necessary.
        // 看是不是需要添加工作线程
        // 如果线程池至少处于 SHUTDOWN 状态，并且满足以下任意一个条件：
        //   - 线程池处于 STOP 状态；
        //   - 当前线程已经有初始任务；
        //   - 任务队列为空；
        // 则返回 false，表示不允许添加新线程或任务。
        if (runStateAtLeast(c, SHUTDOWN)
            && (runStateAtLeast(c, STOP)
                || firstTask != null
                || workQueue.isEmpty()))
            return false;

        // 采用自旋 + CAS 让工作线程 +1
        for (;;) {
            // 目前线程数 >= 线程池可以创建的理论线程数最大值则不再创建工作线程，
            // 或者要创建核心线程但线程池线程数已经达到 corePoolSize，
            // 或者要创建非核心线程但线程池线程数已经达到 maximumPoolSize，
            // 这两种情况也不再创建工作线程，直接返回添加工作线程失败标识。
            if (workerCountOf(c)
                >= ((core ? corePoolSize : maximumPoolSize) & COUNT_MASK))
                return false;

            // CAS 成功了，跳出循环
            if (compareAndIncrementWorkerCount(c))
                break retry;

            // 重新判断，回到开始，判断是不是结束了
            c = ctl.get();  // Re-read ctl 拿到最新的值
            if (runStateAtLeast(c, SHUTDOWN))
                continue retry;

            // else CAS failed due to workerCount change; retry inner loop
        }
    }

    // 下面是真正的创建一个线程
    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {
        // 真正的线程
        w = new Worker(firstTask);
        final Thread t = w.thread;
        if (t != null) {
            // 加锁
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                // Recheck while holding lock.
                // Back out on ThreadFactory failure or if
                // shut down before lock acquired.
                int c = ctl.get();
                if (isRunning(c) ||
                    (runStateLessThan(c, STOP) && firstTask == null)) {
                    if (t.getState() != Thread.State.NEW)
                        throw new IllegalThreadStateException();
                    workers.add(w);
                    workerAdded = true;
                    int s = workers.size();
                    if (s > largestPoolSize)
                        largestPoolSize = s;
                }
            } finally {
                mainLock.unlock();
            }
            if (workerAdded) {
                // 启动工作线程
                t.start();
                workerStarted = true;
            }
        }
    } finally {
        // 工作线程没有启动，进行回滚
        if (!workerStarted)
            addWorkerFailed(w);
    }
    return workerStarted;
}
```


| **firstTask（Runnable）** | **core（boolean）** | **作用**                                                                               |
| ----------------------- | ----------------- | ------------------------------------------------------------------------------------ |
| command                 | true              | 将要创建核心线程，command任务不放入队列，直接在创建的线程中执行，一般是核心线程数未达到corePoolSize时使用                       |
| command                 | false             | 这种情况是在核心线程数已达到corePoolSize，将任务放入阻塞队列时失败了，所以这时候就创建非核心线程并将当前任务command立即执行              |
| null                    | true              | 这种情况一般是在线程池预热情况下使用，比如调用prestartCoreThread方法预热启动一个线程，prestartAllCoreThreads预热启动所有核心线程 |
| null                    | false             | 这种一般是阻塞队列中还有任务，但线程池没有工作线程了，这时候就创建一个工作线程去阻塞队列拿任务执行                                    |


**Worker类：**


```java
private final class Worker extends AbstractQueuedSynchronizer implements Runnable {
    // Worker的Thread属性，其实干活的就是这个线程
    final Thread thread;
    // 任务
    Runnable firstTask;
    // 线程已经执行完成的任务总数
    volatile long completedTasks;

    // 构造方法
    Worker(Runnable firstTask) {
        setState(-1); // inhibit interrupts until runWorker
        this.firstTask = firstTask;
        // 以当前对象创建Thread线程，线程执行时调用的就是这个类的run方法
        this.thread = getThreadFactory().newThread(this);
    }

    // run方法执行任务，调用的是外部ThreadPoolExecutor的runWorker方法
    public void run() {
        runWorker(this);
    }
    ...
}
```


### 执行方法


![imagesc5677645ab72ba8cc1b198e203bb98e4.png](/images/c7e9cb08aa8f7d8c9c48e0ffebfa25bb.png)


```java
final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null; // 默认是-1（在构造函数的时候），不允许打断
    w.unlock(); // allow interrupts

    boolean completedAbruptly = true;
    try {
        // 任务不为空，并且能获取到任务（好像有超时时间）
        while (task != null || (task = getTask()) != null) {
            w.lock();
            // If pool is stopping, ensure thread is interrupted;
            // if not, ensure thread is not interrupted.  This
            // requires a recheck in second case to deal with
            // shutdownNow race while clearing interrupt
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &&
                  runStateAtLeast(ctl.get(), STOP))) &&
                !wt.isInterrupted())
                wt.interrupt();

            try {
                // 执行前的逻辑
                beforeExecute(wt, task);
                try {
                    task.run();
                    afterExecute(task, null);
                } catch (Throwable ex) {
                    afterExecute(task, ex);
                    throw ex;
                }
            } finally {
                task = null;
                w.completedTasks++;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        processWorkerExit(w, completedAbruptly);
    }
}
```


```java
private Runnable getTask() {
    boolean timedOut = false; // Did the last poll() time out?
    // 循环调用，其中会判断线程池状态
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);
        // 线程池即将关闭状态，如果阻塞队列中也没有任务了，返回null，runWorker方法没有拿到task则退出while循环，销毁线程。
        // 这里根据shutdown和shutdownNow设置不同的线程池状态走不同的逻辑
        // 如果线程池状态是STOP则直接线程数减1，然后返回null，runWorker方法会退出while循环，线程销毁
        // 如果线程池状态是SHUTDOWN则再看看阻塞队列是否为空，为空则线程数减1，后续线程销毁，不会空则继续获取任务
        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
            decrementWorkerCount();
            return null;
        }
        // 获取当前线程数
        int wc = workerCountOf(c);
        // 是否允许超时标识，allowCoreThreadTimeOut核心线程是否允许超时
        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;
        // 非核心线程过多或者允许超时的情况下，如果队列为空则工作线程减1，后续销毁线程，这里就返回null
        if ((wc > maximumPoolSize || (timed && timedOut))
                && (wc > 1 || workQueue.isEmpty())) {
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        }
        try {
            // 允许核心线程超时或者线程数大于核心线程数时，采用poll取数据，非阻塞，超过keepAliveTime没有获取到数据就继续自旋获取任务，
            // 不允许核心线程超时或者线程数小于等于核心线程数时，采用take取数据，阻塞等待直到获取到任务或者被中断
            Runnable r = timed ?
                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                    // 直接给你阻塞了
                    workQueue.take();
            if (r != null)
                return r;
            timedOut = true;
        } catch (InterruptedException retry) {
            timedOut = false;
        }
    }
}
```


# tomcat线程池


主要就是在队列的offer（添加到队列）的方法中


![images185cc30e16e181c0462e1096f68c838d.webp](/images/6852f1f49810e05cfbb448cc0f253378.webp)


在④中，判断是不是数量不够，不够返回false，然后机会继续添加线程了

