---
categories: ''
tags: []
description: ''
permalink: ''
title: 分布式事务的解决方案
date: '2025-09-14 17:39:00'
updated: '2025-09-14 17:45:00'
---

# 什么是分布式事务


指事务的发起者，资源以及资源管理器和事务协调者分别位于分布式系统的不同节点之上。


本质来说，分布式事务就是为了保证在分布式场景下，数据操作的正确执行


# ACID


分布式事务会部分遵循 ACID 规范：

- 原子性：严格遵循
- 一致性：事务完成后的一致性严格遵循；事务中的一致性可适当放宽
- 隔离性：并行事务间不可影响；事务中间结果可见性允许安全放宽
- 持久性：严格遵循

因为事务过程中，不是一致的，但事务会最终完成，最终达到一致，所以我们把分布式事务称为“最终一致”


# 基本解决方案


| **方案** | **一致性** | **性能** | **复杂度** | **适用场景**     |
| ------ | ------- | ------ | ------- | ------------ |
| 2PC    | 强一致性    | 低      | 中       | 传统数据库、XA协议   |
| 3PC    | 强一致性    | 中低     | 高       | 需减少阻塞的强一致场景  |
| TCC    | 最终一致性   | 高      | 高       | 高并发业务（支付、库存） |
| Saga   | 最终一致性   | 中      | 高       | 长事务、跨服务流程    |
| 消息队列   | 最终一致性   | 高      | 中       | 事件驱动架构       |
| 本地消息表  | 最终一致性   | 中      | 低       | 异步通知（订单-积分）  |


## 二阶段提交


XA是由X/Open组织提出的分布式事务的规范，XA规范主要定义了(全局)事务管理器(TM)和(局部)资源管理器(RM)之间的接口。本地的数据库如mysql在XA中扮演的是RM角色


XA一共分为两阶段：

1. prepare：即所有的参与者（RM）准备执行事务并锁住需要的资源。参与者ready后，向Tm报告已准备就绪。
2. commit/rollback：当事务管理者（TM）确认所有参与者（RM）都ready后，向所有的参与者发送commit命令。

XA 事务由一个或多个资源管理器（RM）、一个事务管理器（TM）和一个应用程序（ApplicationProgram）组成。


这里的RM、TM、AP三个角色是经典的角色划分，会贯穿后续Saga、Tcc等事务模式。


把上面的转账作为例子，一个成功完成的XA事务时序图如下：


![images2e287d0341914013a11459d4f09d5894.png](/images/8ed1aef4c4ab3759e8d8bab323ca6464.png)


如果有任何一个参与者prepare失败，那么TM会通知所有完成prepare的参与者进行回滚。


XA事务的特点是：

- 简单易理解，开发较容易
- 对资源进行了长时间的锁定，并发度低
- 事物管理器故障会影响事物流程

**适用于对数据一致性要求高、并发度低的场景。**


## SAGA


Saga是这一篇数据库论文sagas提到的一个方案。其核心思想是将长事务拆分为多个本地短事务，由Saga事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。


把上面的转账作为例子，一个成功完成的SAGA事务时序图如下：


![imagesd4b3b3cd31771d5c4e0e0e125bd91c4d.png](/images/8656cc8375f8928f8b1591df963d96f8.png)


Saga一旦到了Cancel阶段，那么Cancel在业务逻辑上是不允许失败了。如果因为网络或者其他临时故障，导致没有返回成功，那么TM会不断重试，直到Cancel返回成功。


Saga事务的特点：

- 并发度高，不用像XA事务那样长期锁定资源
- 需要定义正常操作以及补偿操作，开发量比XA大
- 一致性较弱，对于转账，可能发生A用户已扣款，最后转账又失败的情况

论文里面的SAGA内容较多，包括两种恢复策略，包括分支事务并发执行，我们这里的讨论，仅包括最简单的SAGA


SAGA适用的场景较多，长事务适用，对中间结果不敏感的业务场景适用


如果读者想要进一步研究SAGA，可参考[DTM](https://link.segmentfault.com/?enc=NuJFv6K2eUZQR3E0mddk0Q%3D%3D.nWA8dBVCTeBPVGplzp7Uoxfo4k8JXgPee7hMyJxzZsc%3D)，里面包括了SAGA成功、失败回滚的例子，还包括各类网络异常的处理。


# Seata解决方案


![images39e26587065f736f4c23b796aa9b42cc.png](/images/565a5fda871dd52e8234576f19198108.png)


## AT模式


seata在内部做了对数据库的代理层，使用at模式，实际上使用的是seata自带的数据源代理（DataSourceProxy ）Seata 在这层代理中加入了很多逻辑，比如插入回滚 undo_log 日志，检查全局锁等。

> 算是2PC的变种，借鉴了TCC的方式（不去长时间占用锁），锁占有的粒度细了，并发度就变高了。
>
> 这个模式seata帮我们做了TCC要做的事，seata靠它的代理数据源将我们的事务id，分支id，与锁记录保存到它的数据库中，并且将我们的数据副本保存在undo_log表（我们自己的业务库中）
>
>

这么做的代价和TCC相同，伪事务，没有强一致性，只有**最终一致性**


## TCC（最终一致性）

- 防止空回滚
- 防止悬挂（重复的try）
- 幂等校验

以BASE最终一致性为基础，在业务层实现二阶段提交的TCC（Try-Confirm-Canal）分布式事物解决方案


需要定义 try，commit，rollback三个方法，对业入侵大


rollback需要设计成允许空回滚，因为try失败，触发rollback


![images84811411d136e26e432cedef4785e856.png](/images/d320aff8e9456275ab5d347ed4fa809e.png)


悬挂的意思是：Cancel 比 Try 接口先执行，出现的原因是 Try 由于网络拥堵而超时，事务管理器生成回滚，触发 Cancel 接口，而最终又收到了 Try 接口调用，但是 Cancel 比 Try 先到。按照前面允许空回滚的逻辑，回滚会返回成功，事务管理器认为事务已回滚成功，则此时的 Try 接口不应该执行，否则会产生数据不一致，所以我们在 Cancel 空回滚返回成功之前先记录该条事务 xid 或业务主键，标识这条记录已经回滚过，Try 接口先检查这条事务xid或业务主键如果已经标记为回滚成功过，则不执行 Try 的业务操作。


## Saga


Saga 模式是 SEATA 提供的长事务解决方案，在 Saga 模式中，业务流程中每个参与者都提交本地事务，当出现某一个参与者失败则补偿前面已经成功的参与者，一阶段正向服务和二阶段补偿服务都由业务开发实现。


Saga 是一种补偿协议，在 Saga 模式下，分布式事务内有多个参与者，每一个参与者都是一个冲正补偿服务，需要用户根据业务场景实现其正向操作和逆向回滚操作。


分布式事务执行过程中，依次执行各参与者的正向操作，如果所有正向操作均执行成功，那么分布式事务提交。如果任何一个正向操作执行失败，那么分布式事务会退回去执行前面各参与者的逆向回滚操作，回滚已提交的参与者，使分布式事务回到初始状态。


Saga 理论出自 Hector & Kenneth 1987发表的论文 Sagas。


Saga 正向服务与补偿服务也需要业务开发者实现。


特点：

- 业务流程长，业务流程多

缺点：

- 没有隔离性

## XA（实时一致性）

