---
categories: 算法
tags: []
description: ''
permalink: dynamic-programming-quick-reference
title: 动态规划速查
date: '2025-09-14 17:39:00'
updated: '2025-09-14 18:46:00'
---

# 路径问题


这种一般都是一个二维列表，很容易推导出转移方程


# 背包问题


## 01背包


有N件物品和一个容量位V的背包。每件物品有且只有一件


第i件物品的体积是v[i]，价值是w[i]，求他们装进背包的最大价值


### dp[N][C+1]解法


状态定义：考虑前i件物品，使用容量不超过C的条件下的背包的最大价值


二维数组： 一维表示当前枚举到哪个物品，另外一维表示现在剩余的容量


![images1120a40a48e0202e1181639cc5cb90a6.svg](/images/85d50debb1df0feb69a5e68b9cfbdb82.svg)


image


```java
public int maxValue(int N, int C, int[] v, int[] w) {    int[][] dp = new int[N][C + 1];    // 处理第一件物品    for (int i = 0; i <= C; i++) {        dp[0][i] = i >= v[0] ? w[0] : 0;    }    for (int i = 0; i < N; i++) {        for (int j = 0; j <= C; j++) {            // 不选这个物品            int n = dp[i - 1][j];            // 选这个物品（状态转移            int y = j > v[i] ? dp[i - 1][j - v[i]] + w[i] : 0;            dp[i][j] = Math.max(n, y);        }    }    return dp[N - 1][C];}
```


### dp[C+1] 解法


转移方程总体如下：


![images1120a40a48e0202e1181639cc5cb90a6.svg](/images/eb301483490a8c4349af11dd7d467f30.svg)


image


可以看到转移方程只需要当前位置的上一个元素和左边的元素


![images08027e986170d41a37e82757c8c1a95d.webp](/images/4edd395173161cf6614f21d59b1468c3.webp)


所以 **我们直接倒序遍历**


```java
public int maxValue(int N, int C, int[] v, int[] w) {       int[] dp=new int[C+1];
       // 还少了初始化第一行        for (int i = 0; i < N; i++) {            int val=v[i];           for (int j = C; j >= val; j++) {            dp[j]=Math.max(dp[j], dp[j-val]+w[i]);           }        }        return dp[C];    }
```


## 完全背包


![images6e3fcb1ca3e8a5e1f09a11119f4d13f6.png](/images/3365057326d2a8368ad32fdc75efb0a8.png)


朴素解法：


![images98009035c21c9ad90f5ad278f47fd708.svg](/images/d50ad852b888ad06d7752731db57d41d.svg)


image


因为是每个都可以选，所以设置可以选择了k次


一维解法：从小到大的解法


```java
public int maxValue(int N, int C, int[] v, int[] w) {        int[] dp = new int[C + 1];        for (int i = 0; i < N; i++) {            for (int j = 0; j <= C; j++) {                // 不考虑第 i 件物品的情况（选择 0 件物品 i）                int n = dp[j];                // 考虑第 i 件物品的情况                int y = j - v[i] >= 0 ? dp[j - v[i]] + w[i] : 0;
                dp[j] = Math.max(n, y);            }        }        return dp[C];    }
```


# 状态压缩


[691. 贴纸拼词 - 力扣（LeetCode）](https://leetcode.cn/problems/stickers-to-spell-word/solutions/135103/zhuang-tai-ya-suo-dpji-you-hua-by-lucifer1004/)


```java
class Solution {    public int minStickers(String[] stickers, String target) {        /*        状态压缩+dp:        序列化形式为target当前索引位选了就置1,没选就为0,,因此有 msk = 1<<n 种情形->000...->111...        1.状态定义:dp[i]为到达状态i所需要的最少贴纸数目,其中i为int类型表示的状态        2.状态转移:dp[i]=min(dp[i], dp[k]+1) 其中dp[k]为k状态(比i状态少一张贴纸)        3.初始化:初始化dp[0]=0 其余初始化为INF 方便覆盖 因为达到什么都不选的状态只需0张贴纸        4.遍历顺序:遍历形式非常讲究,也是最关键的一步            4.1 先遍历每个状态 state:0->mask-1            4.2 再遍历每一张贴纸stickers[i],判断当前mask加成这张stickers[i]后能转移到哪个新的状态            4.3 最后遍历当前mask的每一位,一位一位进行转移            一般是某个数&1转移新状态,因此整个遍历过程都是正序        5.返回形式:dp[i]==INF?-1:dp[mask-1]         */        int INF = 0x3f3f3f3f;        int n = target.length();        int mask = 1 << n;        // 状态i对应的最少贴纸数        int[] dp = new int[mask];   // 00000..-11111..        Arrays.fill(dp, INF);        dp[0] = 0;        // 遍历每个状态:注意从0开始转移        for (int i = 0; i < mask; i++) {            if (dp[i] == INF) continue; // 无法从此处开始转移(无效值)            // 遍历每张贴纸            for (String ss : stickers) {                // cur为新的状态,len为这张贴纸长度                int cur = i, len = ss.length();                // 遍历该张贴纸的每个字母                for (int k = 0; k < len; k++) {                    char c = ss.charAt(k);                    // 遍历target每个位置判断c能够填充的位置                    for (int p = 0; p < n; p++) {                        // 若遇到target中与c相等的字母 && 该位置还没填充                        if (target.charAt(p) == c && (((cur >> p) & 1) == 0)) {                            cur |= (1 << p);    // 填充                            break;  // 每张贴纸某个字母只能填充一个位置                            // 退出该层循环继续遍历该贴纸的下一个字母                        }                    }                }                // 遍历完这张贴纸后,说明dp[cur]多了一条转移路径:dp[i]->dp[cur]                // 而dp[cur]=dp[i]+1 维护dp[cur]最小值也就是所有转移路径最小值(因为要求最小值)                dp[cur] = Math.min(dp[cur], dp[i] + 1);            }        }        // 全选状态:没有转移就说明无法到达返回-1 否则返回对应dp值        return dp[mask - 1] == INF ? -1 : dp[mask - 1];    // 1111...    }}
```


# 线性dp


**线性动态规划**：具有「线性」阶段划分的动态规划方法统称为线性动态规划（简称为「线性 DP」），如下图所示。


![imagesff2aaae531b191add328fda5098583f5.png](/images/76fa9bd0ff22a58f2e85fead80b6f4a6.png)


如果状态包含多个维度，但是每个维度上都是线性划分的阶段，也属于线性 DP。比如[背包问题](https://so.csdn.net/so/search?q=%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98&spm=1001.2101.3001.7020)、区间 DP、数位 DP 等都属于线性 DP。


线性 DP 问题的划分方法有多种方式。

- 如果按照「状态的维度数」进行分类，我们可以将线性 DP 问题分为：一维线性 DP 问题、二维线性 DP 问题，以及多维线性 DP 问题。
- 如果按照「问题的输入格式」进行分类，我们可以将线性 DP 问题分为：单串线性 DP 问题、双串线性 DP 问题、矩阵线性 DP 问题，以及无串线性 DP 问题。

[骑士在棋盘上的概率](https://leetcode.cn/problems/knight-probability-in-chessboard/)


[808. 分汤 - 力扣（LeetCode）](https://leetcode.cn/problems/soup-servings/solutions/1982919/by-joneli-ts7a/)


# 关于一些位运算的技巧


## 看第i位是否为1


```java
((s >> i) & 1) == 1// 它在Java中用来检查整数s的二进制表示中的第i位是否为1
```


右移：减半相当于除以2


## 位掩码


```java
1<<m
结果就是2的n次方
 for (int i = 1; i < 1 << m; ++i) {            for (int j = 0; j < m; ++j) {                // 第二个循环表示是右移j位 判断这个是不是在这个集合中的                if (((i >> j) & 1) == 1) {                    t += nums[j];                }            }}// 例如 m=3  那么就是8个 ，并且判断每一个位置
```

